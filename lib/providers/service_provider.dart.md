# Service Provider Documentation

## Overview
The `service_provider.dart` file contains the comprehensive state management solution for service operations in the AI-Enabled Tailoring Shop Management System. It extends `ChangeNotifier` to provide reactive state management for service catalog, filtering, analytics, and intelligent recommendations.

## Architecture

### Core Features
- **Service CRUD Operations**: Complete service lifecycle management
- **Advanced Filtering**: Multi-criteria search and categorization
- **Business Analytics**: Comprehensive service performance metrics
- **Intelligent Recommendations**: AI-powered service suggestions
- **Real-time Updates**: Stream-based live service synchronization
- **Bulk Operations**: Efficient batch service management

### State Management
```dart
class ServiceProvider with ChangeNotifier {
  // Core data
  List<Service> _services = [];
  List<Service> _filteredServices = [];

  // UI state
  bool _isLoading = false;
  String? _errorMessage;

  // Filters
  String _searchQuery = '';
  ServiceCategory? _selectedCategoryFilter;
  ServiceType? _selectedTypeFilter;
  bool? _activeStatusFilter;

  // Analytics
  Map<ServiceCategory, int> _categoryStats = {};
  Map<ServiceType, int> _typeStats = {};
  double _totalRevenue = 0.0;
  int _totalBookings = 0;
}
```

## Core Functionality

### Service Data Management

#### Loading Services
```dart
Future<void> loadServices()
```
- Loads all services from Firestore collection
- Calculates comprehensive statistics automatically
- Applies current filters and updates UI
- Handles loading states and error management
- Updates through `notifyListeners()`

#### Real-time Service Stream
```dart
Stream<List<Service>> getServicesStream()
```
- Provides real-time updates when service data changes
- Automatically maps Firestore documents to Service objects
- Enables reactive UI updates without manual polling

#### CRUD Operations
- **`createService()`**: Creates new service with timestamp tracking
- **`updateService()`**: Updates service data with local cache management
- **`deleteService()`**: Removes services with cascade cleanup
- **`activateService()`/`deactivateService()`**: Quick status toggles

### Advanced Filtering System

#### Filter Types
- **Text Search**: Searches across name, description, category, and type
- **Category Filter**: Filters by service category (saree, garments, etc.)
- **Type Filter**: Filters by specific service type within category
- **Active Status**: Filters by active/inactive status

#### Filter Implementation
```dart
void _applyFilters() {
  List<Service> filtered = _services;

  // Apply search filter
  if (_searchQuery.isNotEmpty) {
    filtered = filtered.where((service) {
      return service.name.toLowerCase().contains(_searchQuery) ||
             service.description.toLowerCase().contains(_searchQuery) ||
             service.categoryName.toLowerCase().contains(_searchQuery) ||
             service.typeName.toLowerCase().contains(_searchQuery);
    }).toList();
  }

  // Apply additional filters...
  _filteredServices = filtered;
  notifyListeners();
}
```

### Business Analytics

#### Service Statistics
```dart
// Computed properties
Map<ServiceCategory, int> get categoryStats => _categoryStats;
Map<ServiceType, int> get typeStats => _typeStats;
double get totalRevenue => _totalRevenue;
int get totalBookings => _totalBookings;

double get averageServicePrice {
  if (_services.isEmpty) return 0.0;
  return _services.map((s) => s.effectivePrice).reduce((a, b) => a + b) / _services.length;
}
```

#### Category Analytics
```dart
Map<String, dynamic> getCategoryAnalytics(ServiceCategory category)
```
Provides comprehensive category insights:
- **Service Counts**: Total and active services in category
- **Revenue Metrics**: Total revenue generated by category
- **Performance Data**: Average ratings and booking volumes
- **Top Performers**: Popular and highly-rated services

#### Revenue Analytics
```dart
Map<String, dynamic> getRevenueAnalytics()
```
Business intelligence including:
- **Revenue Breakdown**: Total and category-wise revenue
- **Top Performers**: Highest revenue-generating services
- **Service Metrics**: Average pricing and booking trends
- **Market Insights**: Revenue distribution across categories

### Intelligent Recommendations

#### Service Recommendations
```dart
List<Service> getRecommendedServices({
  String? forServiceId,
  ServiceCategory? category,
  double? budget
})
```
AI-powered recommendations based on:
- **Similarity Matching**: Services with same category or type
- **Popularity Scoring**: Weighted algorithm using popularity and ratings
- **Budget Filtering**: Price range-appropriate suggestions
- **Exclusion Logic**: Prevents recommending the current service

#### Recommendation Algorithm
```dart
// Sort by popularity and rating
recommended.sort((a, b) {
  final aScore = (a.popularityScore * 0.7) + (a.averageRating * 20);
  final bScore = (b.popularityScore * 0.7) + (b.averageRating * 20);
  return bScore.compareTo(aScore);
});
```

### Individual Service Analytics

#### Service Performance
```dart
Map<String, dynamic> getServiceAnalytics(String serviceId)
```
Detailed service insights:
- **Popularity Ranking**: Service ranking among all active services
- **Revenue Generation**: Total revenue from the service
- **Booking Trends**: Current vs. average booking comparison
- **Similar Services**: Related services for cross-selling

#### Trend Analysis
```dart
Map<String, dynamic> _calculateBookingTrend(Service service)
```
Booking trend analysis:
- **Current Performance**: Recent booking numbers
- **Market Comparison**: Against average service performance
- **Trend Direction**: Upward or downward trend indication
- **Percentage Change**: Quantified performance change

### Bulk Operations

#### Batch Management
```dart
Future<bool> bulkUpdateServices(List<String> serviceIds, Map<String, dynamic> updates)
```
Efficient batch operations:
- **Bulk Updates**: Update multiple services simultaneously
- **Status Management**: Activate/deactivate multiple services
- **Price Adjustments**: Bulk pricing modifications
- **Category Changes**: Mass category reassignments

#### Quick Actions
```dart
Future<bool> activateService(String serviceId)
Future<bool> deactivateService(String serviceId)
```
Immediate service status changes with automatic UI updates.

### Sample Data Management

#### Template Integration
```dart
Future<void> initializeSampleServices()
```
- Integrates with `ServiceTemplates` for sample data
- Creates predefined services for demonstration
- Supports development and testing workflows
- Prevents duplicate data creation

## Firebase Integration

### Data Operations
- **Collection**: `services` - Main service catalog
- **Real-time Streams**: Live updates for service changes
- **Document Relationships**: Links to categories and types
- **Timestamp Tracking**: Creation and update timestamps

### Data Flow
```dart
// Load services with analytics
await loadServices(); // Includes _calculateStats()

// Real-time updates
Stream<List<Service>> serviceStream = getServicesStream();

// Create new service
await createService(service); // Includes timestamp handling

// Update with local cache management
await updateService(serviceId, updates); // Optimistic updates
```

## Usage Examples

### Service Catalog Screen
```dart
class ServiceCatalogScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<ServiceProvider>(
      builder: (context, serviceProvider, child) {
        if (serviceProvider.isLoading) {
          return CircularProgressIndicator();
        }

        return Column(
          children: [
            // Analytics Summary
            Row(
              children: [
                Text('Total Services: ${serviceProvider.services.length}'),
                Text('Revenue: \$${serviceProvider.totalRevenue}'),
                Text('Avg Price: \$${serviceProvider.averageServicePrice}'),
              ],
            ),

            // Service Grid
            Expanded(
              child: GridView.builder(
                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: 2,
                ),
                itemCount: serviceProvider.services.length,
                itemBuilder: (context, index) {
                  final service = serviceProvider.services[index];
                  return ServiceCard(
                    service: service,
                    onTap: () => _viewServiceDetails(context, service),
                  );
                },
              ),
            ),
          ],
        );
      },
    );
  }
}
```

### Advanced Filtering Interface
```dart
class ServiceFilters extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    final serviceProvider = Provider.of<ServiceProvider>(context);

    return Column(
      children: [
        // Search Bar
        TextField(
          decoration: InputDecoration(labelText: 'Search services'),
          onChanged: (value) => serviceProvider.searchServices(value),
        ),

        // Category Filter
        DropdownButton<ServiceCategory>(
          hint: Text('All Categories'),
          value: serviceProvider.selectedCategoryFilter,
          items: ServiceCategory.values.map((category) {
            return DropdownMenuItem(
              value: category,
              child: Text(category.toString().split('.').last),
            );
          }).toList(),
          onChanged: (category) => serviceProvider.filterByCategory(category),
        ),

        // Type Filter
        DropdownButton<ServiceType>(
          hint: Text('All Types'),
          value: serviceProvider.selectedTypeFilter,
          items: ServiceType.values.map((type) {
            return DropdownMenuItem(
              value: type,
              child: Text(type.toString().split('.').last),
            );
          }).toList(),
          onChanged: (type) => serviceProvider.filterByType(type),
        ),
      ],
    );
  }
}
```

### Service Analytics Dashboard
```dart
class ServiceAnalyticsScreen extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<ServiceProvider>(
      builder: (context, serviceProvider, child) {
        final revenueAnalytics = serviceProvider.getRevenueAnalytics();

        return Column(
          children: [
            Text('Total Revenue: \$${revenueAnalytics['totalRevenue']}'),
            Text('Total Bookings: ${revenueAnalytics['totalBookings']}'),
            Text('Average Price: \$${revenueAnalytics['averageServicePrice']}'),

            // Category Performance
            ...ServiceCategory.values.map((category) {
              final categoryAnalytics = serviceProvider.getCategoryAnalytics(category);
              return ListTile(
                title: Text(category.toString().split('.').last),
                subtitle: Text('Revenue: \$${categoryAnalytics['totalRevenue']}'),
                trailing: Text('${categoryAnalytics['totalServices']} services'),
              );
            }),
          ],
        );
      },
    );
  }
}
```

### Service Recommendations
```dart
class ServiceRecommendations extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Consumer<ServiceProvider>(
      builder: (context, serviceProvider, child) {
        final recommended = serviceProvider.getRecommendedServices(
          category: ServiceCategory.sareeServices,
          budget: 100.0,
        );

        return Column(
          children: recommended.map((service) {
            return ListTile(
              title: Text(service.name),
              subtitle: Text('\$${service.effectivePrice}'),
              trailing: Text('${service.averageRating}â­'),
              onTap: () => _selectService(service),
            );
          }).toList(),
        );
      },
    );
  }
}
```

## Integration Points

### Related Components
- **Service Model**: Core data structure for service information
- **Service Templates**: Predefined service configurations
- **Service Management Screens**: UI components for service operations
- **Order Provider**: Service selection and booking integration
- **Analytics Service**: Performance metrics and reporting

### Dependencies
- **Firebase Firestore**: Data persistence and real-time subscriptions
- **Cloud Firestore**: Timestamp handling and data relationships
- **Provider Package**: State management and dependency injection
- **Flutter Framework**: UI updates and reactive programming

## Performance Optimization

### Data Loading Strategies
- **Lazy Loading**: Load service details on demand
- **Pagination**: Handle large service catalogs efficiently
- **Caching**: Cache frequently accessed service data
- **Real-time Updates**: Efficient listeners for live data

### Query Optimization
- **Filtered Queries**: Apply filters before loading full datasets
- **Stream Optimization**: Efficient real-time data subscriptions
- **Batch Operations**: Minimize database round trips
- **Memory Management**: Clear unused data to reduce memory footprint

## Security Considerations

### Data Access Control
- **Service Visibility**: Role-based service access
- **Pricing Security**: Secure pricing information handling
- **Content Moderation**: Service description and image validation
- **Update Authorization**: Permission-based service modifications

### Data Validation
- **Service Data**: Validate service information and requirements
- **Pricing Rules**: Ensure pricing consistency and business rules
- **Category Validation**: Maintain category and type relationships
- **Status Management**: Control service activation and deactivation

## Business Logic

### Service Lifecycle Management
- **Service Creation**: Comprehensive service setup with validation
- **Performance Tracking**: Continuous monitoring and analytics
- **Category Management**: Organized service categorization
- **Popularity Algorithms**: Dynamic service ranking and recommendations

### Revenue Optimization
- **Pricing Strategy**: Dynamic pricing based on service tiers
- **Demand Analysis**: Booking trends and popularity tracking
- **Category Performance**: Revenue optimization by service category
- **Recommendation Engine**: Increased cross-selling opportunities

### Customer Experience
- **Service Discovery**: Easy service browsing and filtering
- **Personalized Recommendations**: Relevant service suggestions
- **Transparent Pricing**: Clear pricing and tier information
- **Quality Assurance**: Rating and review integration

### Analytics and Insights
- **Performance Metrics**: Service utilization and revenue analytics
- **Market Trends**: Category performance and demand patterns
- **Customer Preferences**: Popular services and booking trends
- **Business Intelligence**: Data-driven service optimization

This comprehensive service provider serves as the central hub for all service-related operations, providing a robust foundation for service management with advanced analytics, intelligent recommendations, and seamless integration with the tailoring shop's business processes.